/*
 * Copyright 2010-2018, Tarantool AUTHORS, please see AUTHORS file.
 *
 * Redistribution and use in source and binary forms, with or
 * without modification, are permitted provided that the following
 * conditions are met:
 *
 * 1. Redistributions of source code must retain the above
 *    copyright notice, this list of conditions and the
 *    following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials
 *    provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY <COPYRIGHT HOLDER> ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL
 * <COPYRIGHT HOLDER> OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF
 * THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#include "box.h"
#include "replication.h"
#include "promote.h"
#include "error.h"
#include "msgpuck.h"
#include "xrow.h"
#include "space.h"
#include "schema.h"
#include "schema_def.h"
#include "txn.h"
#include "tuple.h"
#include "iproto_constants.h"
#include "opt_def.h"
#include "info.h"

static const char *promote_msg_type_strs[] = {
	"begin",
	"status",
	"sync",
	"success",
	"error",
};

/** True, if @a msg is created by the current instance. */
static inline bool
promote_msg_is_mine(const struct promote_msg *msg)
{
	return tt_uuid_is_equal(&msg->source_uuid, &INSTANCE_UUID);
}

enum promote_role {
	PROMOTE_ROLE_UNDEFINED = 0,
	PROMOTE_ROLE_INITIATOR,
	PROMOTE_ROLE_OLD_MASTER,
	PROMOTE_ROLE_WATCHER
};

static const char *promote_role_strs[] = {
	"undefined",
	"initiator",
	"old master",
	"watcher",
};

enum promote_phase {
	PROMOTE_PHASE_NON_ACTIVE = 0,
	PROMOTE_PHASE_ERROR,
	PROMOTE_PHASE_SUCCESS,
	PROMOTE_PHASE_IN_PROGRESS,
};

static const char *promote_phase_strs[] = {
	"non-active",
	"error",
	"success",
	"in progress",
};

/**
 * The current promotion state. If the promotion is finished, then
 * the latest one is stored here as a cache for
 * box.ctl.promote_info().
 */
static struct promote_state {
	/**
	 * Each round has an unique identifier of two parts: ID
	 * and UUID. ID is used to order rounds by the time of
	 * their start. Each new round has an ID > than all the
	 * known previous ones. Timestamps can not be used since
	 * clocks are not perfectly sinced over network.
	 */
	int round_id;
	/**
	 * UUID is generated by a promotion initiator and allows
	 * to protect from an error when promotions are started on
	 * different nodes at the same time with the same round
	 * IDs. UUIDs are different in them because of different
	 * initiators.
	 */
	struct tt_uuid round_uuid;
	/** UUID of an old master if known, nil UUID otherwise. */
	struct tt_uuid old_master_uuid;
	/** UUID of an initiator if known, nil UUID otherwise. */
	struct tt_uuid initiator_uuid;
	/** Diagnostics storing the current round error. */
	struct diag diag;
	/**
	 * Condition emited each time the promotion state is
	 * changed.
	 */
	struct fiber_cond on_change;
	/**
	 * Role of the current instance in the current promotion
	 * round.
	 */
	enum promote_role role;
	/**
	 * Current round promotion phase. If the round is
	 * finsihed, the result (error/success) is stored here as
	 * well.
	 */
	enum promote_phase phase;
	/**
	 * Description of the latest thing done during the current
	 * promotion round. It is not persisted anywhere and
	 * exists merely to improve user experience. It is shown
	 * in box.ctl.promote_info().
	 */
	char comment[DIAG_ERRMSG_MAX + 1];
	/**
	 * The current promotion round quorum. Becomes valid only
	 * when an initiator becomes known. Quorum is number of
	 * replicas that should approve the promotion and sync
	 * with the old master before its demotion. The quorum
	 * includes the old master and the initiator.
	 */
	int quorum;
	/**
	 * Number of already collected syncs with the old master.
	 * Valid on the old master and on the initiator if it acts
	 * on behalf of the later.
	 */
	int sync_count;
	/**
	 * The current promotion round timeout. Once it is
	 * exceeded, the round is terminated with persisting that
	 * fact. Becomes valid only when an initiator becomes
	 * known.
	 */
	double timeout;
	/** The promotion timer fiber. */
	struct fiber *timer;
	/**
	 * Number of watchers participating in the current
	 * promotion round. If this value + the initiator equals
	 * the cluster size, then the cluster is read-only. In
	 * such a case the promotion is allowed even though an old
	 * master does not exist. The initiator acts on behalf of
	 * the later then.
	 */
	int watcher_count;
	/**
	 * The current promotion step. It is constantly growing
	 * number for each promotion participant and is used to
	 * persist order of sent messages. Each instance arranges
	 * its messages with step numbers. Also steps are used to
	 * persist relative order of messages from different
	 * sources.
	 */
	int step;
	/**
	 * True if this instance at least once succeeded to commit
	 * its status and set role. Status message contains
	 * is_master flag that actually is persisted read_only cfg
	 * option. So other instances now are aware of this status
	 * and it can not be changed by a user via box.cfg.
	 */
	bool is_role_committed;
} promote_state;

/**
 * Getters for different attributes and properties of the
 * promotion state.
 */

static inline bool
promote_is_active(void)
{
	return promote_state.phase == PROMOTE_PHASE_IN_PROGRESS;
}

static inline bool
promote_is_master_known(void)
{
	return !tt_uuid_is_equal(&promote_state.old_master_uuid, &uuid_nil);
}

static inline bool
promote_is_initiator_known(void)
{
	return !tt_uuid_is_equal(&promote_state.initiator_uuid, &uuid_nil);
}

static inline bool
promote_is_finished(void)
{
	return !promote_is_active() && promote_state.timer == NULL;
}

static inline bool
promote_is_cluster_readonly(void)
{
	return promote_state.watcher_count + 1 == replicaset.applier.total;
}

static inline bool
promote_is_this_round_msg(const struct promote_msg *msg)
{
	return promote_is_active() &&
	       tt_uuid_is_equal(&msg->round_uuid, &promote_state.round_uuid);
}

/**
 * Comment a promotion event. The comment text is available to be
 * seen from box.ctl.promote_info(), and is logged.
 */
#define promote_comment(...) do { \
	snprintf(promote_state.comment, sizeof(promote_state.comment), \
		 __VA_ARGS__); \
	say_info(promote_state.comment); \
} while(0)

/**
 * Serialize the promotion message into a string.
 * @param msg Message to serialize.
 * @retval String with the serialized message.
 */
static inline const char *
promote_msg_str(const struct promote_msg *msg)
{
	int offset = 0;
	char *buf = tt_static_buf();
	int len = TT_STATIC_BUF_LEN;

	offset += snprintf(buf, len, "{id: %d, round: '", msg->round_id);
	tt_uuid_to_string(&msg->round_uuid, buf + offset);
	offset += UUID_STR_LEN;
	offset += snprintf(buf + offset, len - offset, "', step: %d, source: '",
			   msg->step);
	tt_uuid_to_string(&msg->source_uuid, buf + offset);
	offset += UUID_STR_LEN;
	offset += snprintf(buf + offset, len - offset, "', ts: %f, type: '%s'",
			   msg->ts, promote_msg_type_strs[msg->type]);
	switch (msg->type) {
	case PROMOTE_MSG_BEGIN:
		offset += snprintf(buf + offset, len - offset, ", quorum: %d, "\
				   "timeout: %f}", msg->begin.quorum,
				   msg->begin.timeout);
		break;
	case PROMOTE_MSG_STATUS:
		offset += snprintf(buf + offset, len - offset, ", is_master: "\
				   "%d}", (int) msg->status.is_master);
		break;
	case PROMOTE_MSG_ERROR:
		offset += snprintf(buf + offset, len - offset, ", code: %d, "\
				   "message: '%s'}", msg->error.code,
				   msg->error.message);
		break;
	default:
		offset += snprintf(buf + offset, len - offset, "}");
		break;
	}
	return buf;
}

/**
 * Encode the promotion message into MessagePack tuple ready to
 * be inserted into _promotion space.
 * @param msg Promotion message to encode.
 * @param[out] size_out Size of the result.
 *
 * @retval NULL Error.
 * @retval not NULL MessagePack encoded message.
 */
static const char *
promote_msg_encode(const struct promote_msg *msg, uint32_t *size_out)
{
	size_t size = 1024;
	char *data = region_alloc(&fiber()->gc, size);
	if (data == NULL) {
		diag_set(OutOfMemory, size, "region_alloc", "data");
		return NULL;
	}
	char *begin = data;
	data = mp_encode_array(data, 7);
	data = mp_encode_uint(data, msg->round_id);
	data = mp_encode_str(data, tt_uuid_str(&msg->round_uuid),
			     UUID_STR_LEN);
	data = mp_encode_uint(data, msg->step);
	data = mp_encode_str(data, tt_uuid_str(&msg->source_uuid),
			     UUID_STR_LEN);
	data = mp_encode_double(data, msg->ts);
	const char *type_str = promote_msg_type_strs[msg->type];
	data = mp_encode_str(data, type_str, strlen(type_str));
	switch(msg->type) {
	case PROMOTE_MSG_BEGIN:
		data = mp_encode_map(data, 2);
		data = mp_encode_str(data, "quorum", strlen("quorum"));
		data = mp_encode_uint(data, msg->begin.quorum);
		data = mp_encode_str(data, "timeout", strlen("timeout"));
		data = mp_encode_double(data, msg->begin.timeout);
		break;
	case PROMOTE_MSG_STATUS:
		data = mp_encode_map(data, 1);
		data = mp_encode_str(data, "is_master", strlen("is_master"));
		data = mp_encode_bool(data, msg->status.is_master);
		break;
	case PROMOTE_MSG_ERROR:
		data = mp_encode_map(data, 2);
		data = mp_encode_str(data, "code", strlen("code"));
		data = mp_encode_uint(data, msg->error.code);
		data = mp_encode_str(data, "message", strlen("message"));
		data = mp_encode_str(data, msg->error.message,
				     strlen(msg->error.message));
		break;
	default:
		data = mp_encode_nil(data);
		break;
	};
	*size_out = data - begin;
	assert(*size_out <= size);
	return begin;
}

const struct opt_def promote_msg_begin_format[] = {
	OPT_DEF("quorum", OPT_UINT32, struct promote_msg, begin.quorum),
	OPT_DEF("timeout", OPT_FLOAT, struct promote_msg, begin.timeout),
	OPT_END,
};

const struct opt_def promote_msg_status_format[] = {
	OPT_DEF("is_master", OPT_BOOL, struct promote_msg, status.is_master),
	OPT_END,
};

const struct opt_def promote_msg_error_format[] = {
	OPT_DEF("code", OPT_UINT32, struct promote_msg, error.code),
	OPT_DEF("message", OPT_STRPTR, struct promote_msg, error.message),
	OPT_END,
};

int
promote_msg_decode(const char *data, struct promote_msg *msg)
{
	uint32_t size = mp_decode_array(&data);
	assert(size == 7 || size == 6);
	uint32_t len;
	struct region *region = &fiber()->gc;
	msg->round_id = (int) mp_decode_uint(&data);
	const char *str = mp_decode_str(&data, &len);
	if (tt_uuid_from_strl(str, len, &msg->round_uuid) != 0) {
		diag_set(ClientError, ER_WRONG_PROMOTION_RECORD,
			 BOX_PROMOTION_FIELD_ROUND_UUID, "invalid UUID");
		return -1;
	}
	msg->step = (int) mp_decode_uint(&data);
	str = mp_decode_str(&data, &len);
	if (tt_uuid_from_strl(str, len, &msg->source_uuid) != 0) {
		diag_set(ClientError, ER_WRONG_PROMOTION_RECORD,
			 BOX_PROMOTION_FIELD_SOURCE_UUID, "invalid UUID");
		return -1;
	}
	if (mp_read_double(&data, &msg->ts) != 0 || msg->ts < 0) {
		diag_set(ClientError, ER_WRONG_PROMOTION_RECORD,
			 BOX_PROMOTION_FIELD_TS, "wrong ts");
		return -1;
	}
	str = mp_decode_str(&data, &len);
	msg->type = STRN2ENUM(promote_msg_type, str, len);
	if (msg->type == promote_msg_type_MAX) {
		diag_set(ClientError, ER_WRONG_PROMOTION_RECORD,
			 BOX_PROMOTION_FIELD_TYPE, "wrong type");
		return -1;
	}

	switch(msg->type) {
	case PROMOTE_MSG_BEGIN:
		if (opts_decode(msg, promote_msg_begin_format, &data,
				ER_WRONG_PROMOTION_RECORD,
				BOX_PROMOTION_FIELD_VALUE, region, 2) != 0)
			return -1;
		break;
	case PROMOTE_MSG_STATUS:
		if (opts_decode(msg, promote_msg_status_format, &data,
				ER_WRONG_PROMOTION_RECORD,
				BOX_PROMOTION_FIELD_VALUE, region, 1) != 0)
			return -1;
		break;
	case PROMOTE_MSG_ERROR:
		if (opts_decode(msg, promote_msg_error_format, &data,
				ER_WRONG_PROMOTION_RECORD,
				BOX_PROMOTION_FIELD_VALUE, region, 2) != 0)
			return -1;
		break;
	default:
		if (mp_typeof(*data) != MP_NIL) {
			diag_set(ClientError, ER_WRONG_PROMOTION_RECORD,
				 BOX_PROMOTION_FIELD_VALUE,
				 tt_sprintf("'%s' has to have value nil",
					    promote_msg_type_strs[msg->type]));
			return -1;
		}
		mp_decode_nil(&data);
		break;
	};
	return 0;
}

/**
 * Send the promotion message via its writing into _promotion
 * space.
 * @param ap Variable length argument list. Contains a single
 *        element - pointer to a promotion message to send.
 *
 * @retval -1 Error.
 * @retval 0 Success.
 */
static int
promote_send_f(va_list ap)
{
	const struct promote_msg *msg = va_arg(ap, const struct promote_msg *);
	struct request request;
	memset(&request, 0, sizeof(request));
	request.type = IPROTO_INSERT;
	request.space_id = BOX_PROMOTION_ID;
	uint32_t size;
	request.tuple = promote_msg_encode(msg, &size);
	if (request.tuple == NULL)
		return -1;
	request.tuple_end = request.tuple + size;
	return box_process_sys_dml(&request);
}

/**
 * Wrapper for promote_send_f to send the message in a separate
 * fiber. It is needed to be able to write records into _promotion
 * space from on_commit trigger where core promotion logic is
 * concentrated and a transaction exists already (though it is
 * committed).
 */
static inline int
promote_send(const struct promote_msg *msg)
{
	/*
	 * Do nothing on recovery. If a message was sent on the
	 * previous work session, it would be recovered among next
	 * rows.
	 */
	if (! box_is_configured())
		return 0;
	struct fiber *sender = fiber_new("promote sender", promote_send_f);
	if (sender == NULL)
		return -1;
	say_info("send promotion message: %s", promote_msg_str(msg));
	fiber_set_joinable(sender, true);
	fiber_start(sender, msg);
	int rc = fiber_join(sender);
	if (rc != 0) {
		say_info("promotion message has not sent: %s",
			 box_error_message(box_error_last()));
	}
	return rc;
}

/**
 * Create the promotion message.
 * @param[out] msg Message to create.
 * @param type Type to set to @a msg.
 */
static inline void
promote_msg_create(struct promote_msg *msg, enum promote_msg_type type)
{
	msg->round_id = promote_state.round_id;
	msg->round_uuid = promote_state.round_uuid;
	msg->source_uuid = INSTANCE_UUID;
	msg->ts = fiber_time();
	msg->type = type;
	msg->step = ++promote_state.step;
}

/**
 * Send a 'begin' promotion message. For this a new round is
 * initialized and round_id is incremented.
 */
static inline int
promote_send_begin(int quorum, double timeout)
{
	struct promote_msg msg;
	promote_msg_create(&msg, PROMOTE_MSG_BEGIN);
	tt_uuid_create(&msg.round_uuid);
	msg.begin.quorum = quorum;
	msg.begin.timeout = timeout;
	msg.round_id++;
	msg.step = 1;
	return promote_send(&msg);
}

/**
 * Send a 'status' promotion message. It contains a role of this
 * instance. The message is sent as a response to 'begin' message.
 */
static inline int
promote_send_status(void)
{
	struct promote_msg msg;
	promote_msg_create(&msg, PROMOTE_MSG_STATUS);
	msg.status.is_master = ! box_is_ro();
	return promote_send(&msg);
}

/**
 * Send a 'sync' promotion message. It is sent by this instance if
 * it is an old master to be demoted. Sync brings this instance
 * into read-only mode, while watchers and the initiator responds
 * to this message with 'success'.
 */
static inline int
promote_send_sync(void)
{
	struct promote_msg msg;
	promote_msg_create(&msg, PROMOTE_MSG_SYNC);
	return promote_send(&msg);
}

/**
 * Send a 'success' promotion message. It is sent by a promotion
 * watcher and an initiator as a response to 'sync' and by an old
 * master when the sync is successfull. The later means the whole
 * promotion round success.
 */
static inline int
promote_send_success(void)
{
	struct promote_msg msg;
	promote_msg_create(&msg, PROMOTE_MSG_SUCCESS);
	return promote_send(&msg);
}

/**
 * Send an 'error' promotion message. It is sent by any instace
 * on different errors like timeout, multiple masters discovery,
 * local errors (OOM, WAL error etc). This message is sent in
 * scope of the current round and on commit terminates the local
 * promotion state.
 */
static inline int
promote_send_error(void)
{
	struct promote_msg msg;
	promote_msg_create(&msg, PROMOTE_MSG_ERROR);
	struct error *e = box_error_last();
	msg.error.code = box_error_code(e);
	msg.error.message = box_error_message(e);
	return promote_send(&msg);
}

/**
 * Send an 'error' promotion message out of scope of the current
 * round. For example, as a response to unexpected message from
 * another round while there are the current round active.
 */
static inline int
promote_send_out_of_bound_error(int round_id, const struct tt_uuid *round_uuid,
				int step)
{
	struct promote_msg msg;
	promote_msg_create(&msg, PROMOTE_MSG_ERROR);
	msg.round_id = round_id;
	msg.round_uuid = *round_uuid;
	struct error *e = box_error_last();
	msg.error.code = box_error_code(e);
	msg.error.message = box_error_message(e);
	msg.step = step;
	return promote_send(&msg);
}

int
box_check_ro_is_mutable()
{
	if (! promote_state.is_role_committed)
		return 0;
	diag_set(ClientError, ER_CFG, "read_only", "can not change the option "\
		 "when box.ctl.promote() was used");
	return -1;
}

int
box_ctl_promote(double timeout, int quorum)
{
	if (quorum < 0)
		quorum = replicaset.applier.total;
	if (! box_is_ro()) {
		diag_set(ClientError, ER_PROMOTE, "non-initialized",
			 "the initiator is already master");
		return -1;
	}
	if (! promote_is_finished()) {
		diag_set(ClientError, ER_PROMOTE_EXISTS);
		return -1;
	}
	if (quorum <= replicaset.applier.total / 2) {
		diag_set(ClientError, ER_PROMOTE, "non-initialized",
			 tt_sprintf("too small quorum, expected > %d, "\
				    "but got %d", replicaset.applier.total / 2,
				    quorum));
		return -1;
	}
	if (promote_send_begin(quorum, timeout) != 0)
		return -1;

	while (promote_state.phase != PROMOTE_PHASE_SUCCESS) {
		fiber_cond_wait(&promote_state.on_change);
		if (promote_state.phase == PROMOTE_PHASE_ERROR) {
			assert(! diag_is_empty(&promote_state.diag));
			diag_move(&promote_state.diag, diag_get());
			return -1;
		}
	}
	return 0;
}

/**
 * Delete the promotion round with the specified id.
 * @param id Round ID to delete by.
 * @param[out] next_id ID of a next round.
 * @param pk Primary index of the _promotion space.
 *
 * @retval 0 Success.
 * @retval -1 Error.
 */
static inline int
promote_clean_round(uint32_t id, uint32_t *next_id, struct index *pk)
{
	if (! promote_is_finished()) {
		diag_set(ClientError, ER_PROMOTE_EXISTS);
		return -1;
	}
	char key[16];
	mp_encode_uint(key, id);
	if (index_count(pk, ITER_ALL, NULL, 0) == 0)
		return 0;
	struct request request;
	memset(&request, 0, sizeof(request));
	request.type = IPROTO_DELETE;
	request.space_id = BOX_PROMOTION_ID;
	struct iterator *it = index_create_iterator(pk, ITER_GE, key, 1);
	if (it == NULL)
		return -1;
	if (box_txn_begin() != 0) {
		iterator_delete(it);
		return -1;
	}
	struct tuple *t;
	int rc;
	while ((rc = iterator_next(it, &t)) == 0 && t != NULL) {
		uint32_t key_size;
		tuple_field_u32(t, BOX_PROMOTION_FIELD_ID, next_id);
		if (*next_id != id)
			break;
		request.key = tuple_extract_key(t, pk->def->key_def, &key_size);
		if (request.key == NULL)
			goto rollback;
		request.key_end = request.key + key_size;
		if (box_process_sys_dml(&request) != 0)
			goto rollback;
	}
	if (rc != 0 || box_txn_commit() != 0)
		goto rollback;
	iterator_delete(it);
	return 0;
rollback:
	box_txn_rollback();
	iterator_delete(it);
	return -1;
}

int
promote_reset_until(uint32_t until)
{
	uint32_t id, next_id = 0;
	struct index *pk = space_index(space_by_id(BOX_PROMOTION_ID), 0);
	do {
		id = next_id;
		if (promote_clean_round(id, &next_id, pk) != 0)
			return -1;
	} while (id != next_id && next_id < until);
	return 0;
}

int
box_ctl_promote_reset(void)
{
	if (promote_reset_until(UINT32_MAX) != 0)
		return -1;
	promote_state.phase = PROMOTE_PHASE_NON_ACTIVE;
	promote_state.is_role_committed = false;
	return 0;
}

/**
 * Promotion timer worker function. It waits on the promotion
 * state change condition variable at most timeout seconds and
 * if the current round is not finished in time, the timeout error
 * is committed.
 */
static int
promote_timer_f(va_list ap)
{
	(void) ap;
	assert(promote_state.timeout >= 0);
	fiber_set_cancellable(true);
	double timeout = promote_state.timeout;
	double start = fiber_clock();
	while (fiber_cond_wait_timeout(&promote_state.on_change,
				       timeout) == 0) {
		if (!promote_is_active() || fiber_is_cancelled())
			goto stop;
		timeout -= fiber_clock() - start;
		start = fiber_clock();
	}
	if (!promote_is_active() || fiber_is_cancelled())
		goto stop;
	diag_set(ClientError, ER_TIMEOUT);
	promote_state.step++;
	promote_send_error();
stop:
	say_info("promotion timer is stopped");
	assert(fiber() == promote_state.timer);
	promote_state.timer = NULL;
	if (promote_state.role == PROMOTE_ROLE_INITIATOR &&
	    promote_state.phase == PROMOTE_PHASE_SUCCESS)
		promote_reset_until(promote_state.round_id);
	return 0;
}

/**
 * Start a promotion timer to terminate the current round on
 * timeout.
 */
static int
promote_start_timer(void)
{
	assert(promote_state.timer == NULL);
	promote_state.timer = fiber_new("promote timer", promote_timer_f);
	if (promote_state.timer == NULL)
		return -1;
	say_info("start promotion timer for %f seconds", promote_state.timeout);
	fiber_start(promote_state.timer);
	return 0;
}

void
box_ctl_promote_info(struct info_handler *info)
{
	struct promote_state *s = &promote_state;
	info_begin(info);
	if (s->phase == PROMOTE_PHASE_NON_ACTIVE) {
		info_end(info);
		return;
	}
	info_append_int(info, "round_id", s->round_id);
	info_append_str(info, "round_uuid", tt_uuid_str(&s->round_uuid));
	if (promote_is_initiator_known()) {
		info_append_str(info, "initiator_uuid",
				tt_uuid_str(&s->initiator_uuid));
		info_append_int(info, "quorum", s->quorum);
		info_append_double(info, "timeout", s->timeout);
	}
	info_append_str(info, "role", promote_role_strs[s->role]);
	info_append_str(info, "phase", promote_phase_strs[s->phase]);
	info_append_str(info, "comment", s->comment);
	if (promote_is_master_known()) {
		info_append_str(info, "old_master_uuid",
				tt_uuid_str(&s->old_master_uuid));
	}
	info_end(info);
}

void
promote_process(const struct promote_msg *msg)
{
	if (box_is_configured()) {
		say_info("promotion message has %s: %s",
			 promote_msg_is_mine(msg) ? "commited" : "received",
			 promote_msg_str(msg));
	} else {
		say_info("promotion message has recovered: %s",
			 promote_msg_str(msg));
	}
	if (! promote_is_active()) {
		if (msg->round_id <= promote_state.round_id) {
			say_info("Ignored outdated round id %u, expected > %u",
				 msg->round_id, promote_state.round_id);
			return;
		}
		/*
		 * During recovery there are no yields so do them
		 * manually when needed to stop the timer. Avoid
		 * starting a timer is not possible since only a
		 * part of the round could be persisted, so after
		 * the recovery is finished it is necessary to
		 * commit an error on timeout, or finish the round
		 * with success.
		 */
		if (promote_state.timer != NULL) {
			assert(! box_is_configured());
			fiber_cancel(promote_state.timer);
			while (promote_state.timer != NULL)
				fiber_sleep(0);
		}
		promote_state.step = 1;
		promote_state.round_id = msg->round_id;
		promote_state.round_uuid = msg->round_uuid;
		promote_state.old_master_uuid = uuid_nil;
		promote_state.initiator_uuid = uuid_nil;
		diag_clear(&promote_state.diag);
		promote_state.phase = PROMOTE_PHASE_IN_PROGRESS;
		/*
		 * Until 'status' message is commited, the role is
		 * undefined. It is not possible to use
		 * box_is_ro() right here since it can be
		 * recovery. And by recovery of its own 'status'
		 * messages the instance restores its read_only
		 * flag and the role.
		 */
		promote_state.role = PROMOTE_ROLE_UNDEFINED;
		promote_state.sync_count = 0;
		promote_state.watcher_count = 0;
		/*
		 * Begin and quorum can not be set right now,
		 * because the first message may be non-begin and
		 * thus does not contain any round initial info.
		 * It is called messages reordeing and it possible
		 * when, for example, one instance downloads the
		 * same round messages from two different
		 * instances. Some of them can be received
		 * earlier, but commited later breaking the order.
		 * So it is not allowed to trust the order.
		 */
	} else if (!promote_is_this_round_msg(msg)) {
		/*
		 * Do not respond error on error, or else an
		 * infinite error messages exchange will be
		 * started.
		 */
		if (msg->type == PROMOTE_MSG_ERROR)
			return;
		diag_set(ClientError, ER_PROMOTE, tt_uuid_str(&msg->round_uuid),
			 "unexpected message");
		promote_send_out_of_bound_error(msg->round_id, &msg->round_uuid,
						msg->step + 1);
		return;
	} else {
		promote_state.step = MAX(msg->step, promote_state.step);
	}
	/*
	 * The main processing switch. Here each instance of each
	 * type responds to each type of message.
	 */
	switch (msg->type) {
	case PROMOTE_MSG_BEGIN:
		promote_state.initiator_uuid = msg->source_uuid;
		promote_state.quorum = msg->begin.quorum;
		promote_state.timeout = msg->begin.timeout;
		if (promote_start_timer() != 0) {
			promote_send_error();
			break;
		}
		if (! promote_msg_is_mine(msg)) {
			promote_send_status();
		} else {
			promote_state.role = PROMOTE_ROLE_INITIATOR;
			promote_state.is_role_committed = true;
			/*
			 * If an instance sent 'begin' then it was
			 * not a master at the moment of sending.
			 * Recovery this status.
			 */
			box_set_ro(true);
			box_expose_ro();
			promote_comment("promotion is started, my promotion "\
					"role is %s",
					promote_role_strs[promote_state.role]);
		}
		break;

	case PROMOTE_MSG_STATUS:
		if (promote_state.role == PROMOTE_ROLE_UNDEFINED &&
		    promote_msg_is_mine(msg)) {
			/*
			 * An instance can restore its role ONLY
			 * by its own status messages and only on
			 * commit. Even it've just sent the status
			 * one moment earlier. Also the 'status'
			 * message is used to recovery read_only.
			 */
			if (! box_is_ro())
				promote_state.role = PROMOTE_ROLE_OLD_MASTER;
			else
				promote_state.role = PROMOTE_ROLE_WATCHER;
			promote_state.is_role_committed = true;
			box_set_ro(! msg->status.is_master);
			box_expose_ro();
			promote_comment("promotion is started, my promotion "\
					"role is %s",
					promote_role_strs[promote_state.role]);
		}
		if (msg->status.is_master) {
			if (! promote_is_master_known()) {
				promote_state.old_master_uuid =
					msg->source_uuid;
				if (promote_state.role !=
				    PROMOTE_ROLE_OLD_MASTER)
					break;
				if (promote_msg_is_mine(msg)) {
					/* Synced with self. */
					promote_state.sync_count++;
					promote_send_sync();
					break;
				}
			}
			const char *r, *m1, *m2;
			r = tt_uuid_str(&msg->round_uuid);
			m1 = tt_uuid_str(&msg->source_uuid);
			m2 = tt_uuid_str(&promote_state.old_master_uuid);
			/*
			 * Sort master UUIDs to stabilize the
			 * error message. Mostly for tests.
			 */
			if (strcmp(m1, m2) > 0)
				SWAP(m1, m2);
			diag_set(ClientError, ER_PROMOTE, r,
				 tt_sprintf("two masters exist: '%s' and '%s'",
					    m1, m2));
			promote_send_error();
			break;
		}
		++promote_state.watcher_count;
		if (promote_state.role != PROMOTE_ROLE_INITIATOR ||
		    !promote_is_cluster_readonly())
			break;
		/*
		 * The cluster is readonly and 100% available.
		 * Then the promotion is safe allowed. But the
		 * initiator plays for an old master.
		 */
		promote_comment("the cluster is completely readonly, the "\
				"initiator acts on behalf of an old master ");
		/* Synced with self. */
		promote_state.sync_count++;
		promote_send_sync();
		break;

	case PROMOTE_MSG_SYNC:
		if (promote_msg_is_mine(msg)) {
			if (promote_state.role == PROMOTE_ROLE_OLD_MASTER) {
				promote_comment("old master entered readonly "\
						"mode to sync with slaves");
				box_set_ro(true);
				box_expose_ro();
			} else {
				assert(promote_state.role ==
				       PROMOTE_ROLE_INITIATOR);
				assert(promote_is_cluster_readonly());
			}
		} else {
			if (promote_state.role == PROMOTE_ROLE_UNDEFINED) {
				promote_state.is_role_committed = true;
				promote_state.role = PROMOTE_ROLE_WATCHER;
				promote_comment("promotion is started, 'sync' "\
						"is received before my status "\
						"was committed so I am not a "\
						"master and not an initiator, "\
						"but watcher");
				box_set_ro(true);
				box_expose_ro();
			}
			promote_send_success();
		}
		break;

	case PROMOTE_MSG_SUCCESS:
		switch (promote_state.role) {
		case PROMOTE_ROLE_OLD_MASTER:
			/*
			 * The old master sends 'success' to
			 * notify the initiator about the round
			 * successfull finish.
			 */
			if (promote_msg_is_mine(msg)) {
				promote_state.phase = PROMOTE_PHASE_SUCCESS;
				promote_comment("the old master is demoted "\
						"completely");
			} else if (++promote_state.sync_count ==
				   promote_state.quorum) {
				/*
				 * On commit the code above is
				 * called. But do nothing until
				 * the commit.
				 */
				promote_send_success();
			}
			break;
		case PROMOTE_ROLE_INITIATOR:
			/*
			 * The round is finished successfully in
			 * two cases: the old master've sent
			 * 'success' or the cluster is read-only
			 * and each replica've sent 'success'.
			 */
			if (tt_uuid_is_equal(&msg->source_uuid,
					     &promote_state.old_master_uuid) ||
			    (promote_is_cluster_readonly() &&
			     ++promote_state.sync_count ==
			     promote_state.quorum)) {
				promote_comment("the new master is promoted");
				promote_state.phase = PROMOTE_PHASE_SUCCESS;
				box_set_ro(false);
				box_expose_ro();
			}
			break;
		case PROMOTE_ROLE_WATCHER:
			if (promote_msg_is_mine(msg)) {
				promote_state.phase = PROMOTE_PHASE_SUCCESS;
				promote_comment("the watcher has voted and "\
						"left the round");
			}
			break;
		default:
			assert(promote_state.role == PROMOTE_ROLE_UNDEFINED);
			assert(! promote_msg_is_mine(msg));
			break;
		}
		break;

	case PROMOTE_MSG_ERROR:
		if (promote_state.role == PROMOTE_ROLE_OLD_MASTER &&
		    promote_state.phase == PROMOTE_PHASE_IN_PROGRESS &&
		    box_is_ro()) {
			promote_comment("the old master is back in read-write "\
					"mode due to the error: %s",
					 msg->error.message);
			box_set_ro(false);
			box_expose_ro();
		} else {
			promote_comment("the round failed due to the error: %s",
					msg->error.message);
		}
		promote_state.phase = PROMOTE_PHASE_ERROR;
		box_error_raise(msg->error.code, "%s", msg->error.message);
		diag_move(diag_get(), &promote_state.diag);
		break;
	default:
		break;
	}
	promote_state.round_id = MAX(promote_state.round_id, msg->round_id);
	fiber_cond_broadcast(&promote_state.on_change);
}

int
box_ctl_promote_init(void)
{
	memset(&promote_state, 0, sizeof(promote_state));
	fiber_cond_create(&promote_state.on_change);
	return 0;
}
